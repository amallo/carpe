# Règles Cursor pour CarpeApp - Architecture Hexagonale

## Structure du Projet
Ce projet suit une architecture hexagonale avec les couches suivantes :
- `src/app/` : Couche présentation (UI, navigation, composants)
- `src/core/` : Logique métier et infrastructure
- `src/types/` : Définitions TypeScript

## Règles d'Architecture

### Couche Core (`src/core/`)
- Chaque domaine fonctionnel doit avoir sa propre structure :
  - `providers/` : Implémentations concrètes
  - `providers/test/` : Implémentations de test (NON pour la production)
  - `usecases/` : Cas d'usage métier
  - `store/` : État Redux (slices)
  - `services/` : Services métier
  - `generators/` : Générateurs utilitaires

### Couche App (`src/app/`)
- `components/` : Composants réutilisables
- `screens/` : Écrans de l'application
- `navigation/` : Configuration de navigation
- `store/` : Configuration du store Redux
- `config/` : Configuration de l'application

## Conventions de Nommage

### Fichiers
- **Providers** : `*.provider.ts`
- **Use cases** : `*.usecase.ts`
- **Services** : `*.service.ts`
- **Slices Redux** : `*.slice.ts`
- **Tests** : `*.test.ts` ou `__tests__/` directories
- **Types/Interfaces** : `*.interface.ts` ou `*.types.ts`

### Classes et Interfaces
- **Providers** : Suffix `Provider` (ex: `BLEPeerProvider`)
- **Use cases** : Suffix `UseCase` (ex: `PairPeerUseCase`)
- **Services** : Suffix `Service` (ex: `DeviceStatusService`)
- **Interfaces** : Préfix `I` ou suffix `Interface` (ex: `IPeerProvider`)

## Règles de Dépendances

### Flux des Dépendances
- `src/app/` peut importer depuis `src/core/`
- `src/core/` NE PEUT PAS importer depuis `src/app/`
- `src/core/` peut importer depuis `src/types/`
- Les providers de test ne doivent être utilisés que dans les tests

### Injection de Dépendances
- Utiliser `src/core/dependencies.ts` pour définir les interfaces
- Injecter les dépendances via le store Redux
- Préférer les interfaces abstraites aux implémentations concrètes

## Règles TypeScript

### Strict Mode
- Toujours utiliser le mode strict TypeScript
- Définir des types explicites pour les interfaces publiques
- Utiliser des types génériques quand approprié

### Imports
- Préférer les imports nommés aux imports par défaut
- Grouper les imports : React, React Native, tiers, internes
- Utiliser des chemins absolus depuis `src/`

## Règles React Native

### Composants
- Utiliser des composants fonctionnels avec hooks
- Préférer `useCallback` et `useMemo` pour les optimisations
- Utiliser TypeScript strict pour les props

### Navigation
- Définir les types de navigation dans `src/types/`
- Utiliser des noms de routes constants
- Gérer les paramètres de navigation avec TypeScript

## Règles Redux

### Slices
- Un slice par domaine fonctionnel
- Utiliser Redux Toolkit avec `createSlice`
- Définir des types pour l'état et les actions

### Thunks
- Utiliser des thunks pour les opérations asynchrones
- Injecter les dépendances via `extraArgument`
- Gérer les erreurs de manière appropriée

## Règles de Test

### Structure
- Tests unitaires dans `__tests__/` directories
- Tests d'intégration dans `src/core/*/__tests__/`
- Utiliser les providers de test pour les mocks

### Conventions
- Nommer les tests avec le pattern `describe('Feature', () => it('should do something', () => {}))`
- Utiliser des mocks pour les dépendances externes
- Tester les cas d'usage métier

## Règles de Performance

### React Native
- Éviter les re-renders inutiles
- Utiliser `React.memo` pour les composants coûteux
- Optimiser les listes avec `FlatList`

### Redux
- Utiliser des sélecteurs pour éviter les recalculs
- Normaliser l'état pour les listes
- Éviter les mutations d'état

## Règles de Sécurité

### Permissions
- Toujours vérifier les permissions avant utilisation
- Gérer les cas où les permissions sont refusées
- Utiliser les messages d'explication appropriés

### Bluetooth
- Vérifier l'état du Bluetooth avant les opérations
- Gérer les erreurs de connexion
- Implémenter la déconnexion propre

## Règles de Documentation

### Code
- Documenter les interfaces publiques
- Ajouter des commentaires pour la logique complexe
- Utiliser des noms explicites pour les variables et fonctions
- **Tout le code et la documentation doivent être en anglais**

### Architecture
- Maintenir la séparation des couches
- Documenter les cas d'usage métier
- Expliquer les choix d'architecture
- **Toute la documentation technique doit être en anglais**

## Règles de Déploiement

### Environnements
- Utiliser des variables d'environnement pour la configuration
- Séparer les configurations dev/staging/prod
- Ne pas commiter les secrets

### Build
- Configurer les builds pour Android et iOS
- Utiliser Fastlane pour l'automatisation
- Gérer les versions et les builds

## Exceptions et Cas Particuliers

### Providers de Test
- Les fichiers dans `providers/test/` ne doivent JAMAIS être utilisés en production
- Ils sont uniquement pour les tests et le développement
- Ne pas les importer dans le code de production

### Configuration Native
- Les fichiers de configuration native (Android/iOS) suivent leurs propres conventions
- Respecter les bonnes pratiques de chaque plateforme
- Documenter les modifications natives importantes

## Règle de Modification

### Analyse Préalable
Avant toute modification, se poser systématiquement ces questions :
1. **Cette modification concerne-t-elle le core ?** (logique métier, cas d'usage, interfaces abstraites)
2. **Peut-elle être traitée comme un détail d'implémentation ?** (providers, services concrets, configuration)

### En Cas de Doute
Si il y a une incertitude sur :
- Si c'est du core ou de l'implémentation
- Quelle couche devrait être modifiée
- Si c'est un cas d'usage métier ou un détail technique
- Si cela respecte l'architecture hexagonale

**Demander explicitement au développeur** avant de procéder à la modification.

Cette règle garantit le respect de la séparation des responsabilités de l'architecture hexagonale.

## Règles de Craftsmanship et Analyse Critique

### Philosophie du Code Craftsmanship
- **Être extrêmement critique** sur tout code généré ou analysé
- **Détecter systématiquement** les anti-patterns et les fautes de conception
- **Informer immédiatement** dès qu'il y a un doute sur la qualité ou l'architecture
- **Privilégier la qualité** sur la rapidité d'exécution
- **Respecter les principes SOLID** et les bonnes pratiques de l'architecture hexagonale

### Anti-Patterns à Détecter et Éviter

#### Architecture Hexagonale
- ❌ **Violation de la séparation des couches** : Importer depuis `src/app/` dans `src/core/`
- ❌ **Couplage fort** : Dépendances directes entre implémentations concrètes
- ❌ **Leakage d'abstraction** : Exposer des détails d'implémentation dans les interfaces
- ❌ **God Objects** : Classes ou services qui font trop de choses
- ❌ **Tight Coupling** : Dépendances circulaires ou couplage excessif

#### TypeScript et React Native
- ❌ **Any types** : Utiliser `any` au lieu de types explicites
- ❌ **Type assertions non sécurisées** : `as` sans vérification
- ❌ **Props drilling** : Passer des props à travers plusieurs niveaux
- ❌ **Side effects dans les composants** : Logique métier dans les composants UI
- ❌ **Re-renders inutiles** : Pas d'optimisation avec `useCallback`/`useMemo`

#### Redux et State Management
- ❌ **Mutations d'état directes** : Modifier l'état sans utiliser les reducers
- ❌ **Sélecteurs non optimisés** : Pas de memoization des sélecteurs
- ❌ **Actions non typées** : Actions sans payload typé
- ❌ **Side effects dans les reducers** : Logique asynchrone dans les reducers

#### Tests
- ❌ **Tests non isolés** : Tests qui dépendent d'autres tests
- ❌ **Mocks excessifs** : Over-mocking qui masque les vrais problèmes
- ❌ **Tests non significatifs** : Tests qui ne testent rien d'important
- ❌ **Tests fragiles** : Tests qui cassent facilement

### Signaux d'Alerte à Surveiller

#### Code Smells
- **Longueurs excessives** : Méthodes > 20 lignes, classes > 300 lignes
- **Complexité cyclomatique** : Trop de conditions imbriquées
- **Duplication de code** : DRY principle violé
- **Noms non explicites** : Variables/fonctions avec des noms vagues
- **Commentaires excessifs** : Code qui nécessite trop d'explications

#### Architecture Smells
- **Dépendances circulaires** : Modules qui s'importent mutuellement
- **Violation du principe de responsabilité unique** : Classes avec trop de responsabilités
- **Couplage temporel** : Dépendances sur l'ordre d'exécution
- **Magic numbers/strings** : Valeurs hardcodées sans constantes

### Processus d'Analyse Critique

#### Avant Toute Modification
1. **Analyser l'impact** : Cette modification respecte-t-elle l'architecture hexagonale ?
2. **Vérifier les dépendances** : Y a-t-il des violations de la règle de flux des dépendances ?
3. **Évaluer la cohérence** : Le code est-il cohérent avec les patterns existants ?
4. **Identifier les risques** : Quels sont les risques de régression ou de dégradation ?

#### Pendant le Développement
1. **Code review continue** : Analyser chaque ligne de code générée
2. **Tests de conception** : Les tests révèlent-ils des problèmes de conception ?
3. **Refactoring opportuniste** : Améliorer le code existant quand c'est possible
4. **Documentation** : Le code est-il auto-documenté ?

#### Après le Développement
1. **Validation architecturale** : Le code respecte-t-il les principes hexagonaux ?
2. **Performance** : Y a-t-il des problèmes de performance évidents ?
3. **Maintenabilité** : Le code sera-t-il facile à maintenir ?
4. **Évolutivité** : Le code pourra-t-il évoluer sans casser ?

### Communication des Problèmes

#### Quand Signaler un Problème
- **Doute architectural** : Incertitude sur la couche à modifier
- **Anti-pattern détecté** : Violation des bonnes pratiques
- **Code smell** : Indicateur de problème potentiel
- **Performance** : Problème de performance identifié
- **Sécurité** : Risque de sécurité détecté

#### Format de Signalement
```
🚨 PROBLÈME DÉTECTÉ
- Type : [Architecture/Performance/Sécurité/Code Quality]
- Fichier : [chemin du fichier]
- Description : [description du problème]
- Impact : [impact sur le projet]
- Suggestion : [solution proposée]
```

### Exemples de Problèmes Courants

#### Dans le Code Actuel
En analysant `create-identity.usecase.ts`, je détecte plusieurs points d'amélioration :

1. **Incohérence de nommage** : L'interface `CreateIdentityRequest` n'est pas utilisée dans la signature
2. **Duplication de type** : `{nickname: string}` est répété
3. **Manque de validation** : Pas de validation des entrées
4. **Gestion d'erreur** : Pas de try/catch pour les opérations asynchrones

#### Recommandations
- Utiliser l'interface `CreateIdentityRequest` dans la signature
- Ajouter une validation des entrées
- Implémenter une gestion d'erreur appropriée
- Considérer l'ajout d'un service de validation

## Règles Git

### Conventional Commits
- Utiliser le format Conventional Commits pour tous les commits
- Format : `type(scope): description`
- **Tous les commits doivent être en anglais**

#### Types de Commits
- **feat** : Nouvelle fonctionnalité
- **fix** : Correction de bug
- **docs** : Documentation
- **style** : Formatage, point-virgules manquants, etc.
- **refactor** : Refactoring du code
- **test** : Ajout ou modification de tests
- **chore** : Tâches de maintenance, dépendances, etc.

#### Exemples
- `feat(peers): add Bluetooth scanning functionality`
- `fix(permission): fix Android permission handling`
- `refactor(core): restructure dependency injection`
- `test(usecases): add tests for PairPeerUseCase`
- `docs(architecture): document hexagonal organization`

#### Scope
- Utiliser le domaine concerné : `peers`, `permission`, `core`, `app`, etc.
- Ou le fichier/componente spécifique si pertinent
