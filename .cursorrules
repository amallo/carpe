# R√®gles Cursor pour CarpeApp - Architecture Hexagonale

## Structure du Projet
Ce projet suit une architecture hexagonale avec les couches suivantes :
- `src/app/` : Couche pr√©sentation (UI, navigation, composants)
- `src/core/` : Logique m√©tier et infrastructure
- `src/types/` : D√©finitions TypeScript

## R√®gles d'Architecture

### Couche Core (`src/core/`)
- Chaque domaine fonctionnel doit avoir sa propre structure :
  - `providers/` : Impl√©mentations concr√®tes
  - `providers/test/` : Impl√©mentations de test (NON pour la production)
  - `usecases/` : Cas d'usage m√©tier
  - `store/` : √âtat Redux (slices)
  - `services/` : Services m√©tier
  - `generators/` : G√©n√©rateurs utilitaires

### Couche App (`src/app/`)
- `components/` : Composants r√©utilisables
- `screens/` : √âcrans de l'application
- `navigation/` : Configuration de navigation
- `store/` : Configuration du store Redux
- `config/` : Configuration de l'application

## Conventions de Nommage

### Fichiers
- **Providers** : `*.provider.ts`
- **Use cases** : `*.usecase.ts`
- **Services** : `*.service.ts`
- **Slices Redux** : `*.slice.ts`
- **Tests** : `*.test.ts` ou `__tests__/` directories
- **Types/Interfaces** : `*.interface.ts` ou `*.types.ts`

### Classes et Interfaces
- **Providers** : Suffix `Provider` (ex: `BLEPeerProvider`)
- **Use cases** : Suffix `UseCase` (ex: `PairPeerUseCase`)
- **Services** : Suffix `Service` (ex: `DeviceStatusService`)
- **Interfaces** : Pr√©fix `I` ou suffix `Interface` (ex: `IPeerProvider`)

## R√®gles de D√©pendances

### Flux des D√©pendances
- `src/app/` peut importer depuis `src/core/`
- `src/core/` NE PEUT PAS importer depuis `src/app/`
- `src/core/` peut importer depuis `src/types/`
- Les providers de test ne doivent √™tre utilis√©s que dans les tests

### Injection de D√©pendances
- Utiliser `src/core/dependencies.ts` pour d√©finir les interfaces
- Injecter les d√©pendances via le store Redux
- Pr√©f√©rer les interfaces abstraites aux impl√©mentations concr√®tes

## R√®gles TypeScript

### Strict Mode
- Toujours utiliser le mode strict TypeScript
- D√©finir des types explicites pour les interfaces publiques
- Utiliser des types g√©n√©riques quand appropri√©

### Imports
- Pr√©f√©rer les imports nomm√©s aux imports par d√©faut
- Grouper les imports : React, React Native, tiers, internes
- Utiliser des chemins absolus depuis `src/`

## R√®gles React Native

### Composants
- Utiliser des composants fonctionnels avec hooks
- Pr√©f√©rer `useCallback` et `useMemo` pour les optimisations
- Utiliser TypeScript strict pour les props

### Navigation
- D√©finir les types de navigation dans `src/types/`
- Utiliser des noms de routes constants
- G√©rer les param√®tres de navigation avec TypeScript

## R√®gles Redux

### Slices
- Un slice par domaine fonctionnel
- Utiliser Redux Toolkit avec `createSlice`
- D√©finir des types pour l'√©tat et les actions

### Thunks
- Utiliser des thunks pour les op√©rations asynchrones
- Injecter les d√©pendances via `extraArgument`
- G√©rer les erreurs de mani√®re appropri√©e

## R√®gles de Test

### Structure
- Tests unitaires dans `__tests__/` directories
- Tests d'int√©gration dans `src/core/*/__tests__/`
- Utiliser les providers de test pour les mocks

### Conventions
- Nommer les tests avec le pattern `describe('Feature', () => it('should do something', () => {}))`
- Utiliser des mocks pour les d√©pendances externes
- Tester les cas d'usage m√©tier

## R√®gles de Performance

### React Native
- √âviter les re-renders inutiles
- Utiliser `React.memo` pour les composants co√ªteux
- Optimiser les listes avec `FlatList`

### Redux
- Utiliser des s√©lecteurs pour √©viter les recalculs
- Normaliser l'√©tat pour les listes
- √âviter les mutations d'√©tat

## R√®gles de S√©curit√©

### Permissions
- Toujours v√©rifier les permissions avant utilisation
- G√©rer les cas o√π les permissions sont refus√©es
- Utiliser les messages d'explication appropri√©s

### Bluetooth
- V√©rifier l'√©tat du Bluetooth avant les op√©rations
- G√©rer les erreurs de connexion
- Impl√©menter la d√©connexion propre

## R√®gles de Documentation

### Code
- Documenter les interfaces publiques
- Ajouter des commentaires pour la logique complexe
- Utiliser des noms explicites pour les variables et fonctions
- **Tout le code et la documentation doivent √™tre en anglais**

### Architecture
- Maintenir la s√©paration des couches
- Documenter les cas d'usage m√©tier
- Expliquer les choix d'architecture
- **Toute la documentation technique doit √™tre en anglais**

## R√®gles de D√©ploiement

### Environnements
- Utiliser des variables d'environnement pour la configuration
- S√©parer les configurations dev/staging/prod
- Ne pas commiter les secrets

### Build
- Configurer les builds pour Android et iOS
- Utiliser Fastlane pour l'automatisation
- G√©rer les versions et les builds

## Exceptions et Cas Particuliers

### Providers de Test
- Les fichiers dans `providers/test/` ne doivent JAMAIS √™tre utilis√©s en production
- Ils sont uniquement pour les tests et le d√©veloppement
- Ne pas les importer dans le code de production

### Configuration Native
- Les fichiers de configuration native (Android/iOS) suivent leurs propres conventions
- Respecter les bonnes pratiques de chaque plateforme
- Documenter les modifications natives importantes

## R√®gle de Modification

### Analyse Pr√©alable
Avant toute modification, se poser syst√©matiquement ces questions :
1. **Cette modification concerne-t-elle le core ?** (logique m√©tier, cas d'usage, interfaces abstraites)
2. **Peut-elle √™tre trait√©e comme un d√©tail d'impl√©mentation ?** (providers, services concrets, configuration)

### En Cas de Doute
Si il y a une incertitude sur :
- Si c'est du core ou de l'impl√©mentation
- Quelle couche devrait √™tre modifi√©e
- Si c'est un cas d'usage m√©tier ou un d√©tail technique
- Si cela respecte l'architecture hexagonale

**Demander explicitement au d√©veloppeur** avant de proc√©der √† la modification.

Cette r√®gle garantit le respect de la s√©paration des responsabilit√©s de l'architecture hexagonale.

## R√®gles de Craftsmanship et Analyse Critique

### Philosophie du Code Craftsmanship
- **√ätre extr√™mement critique** sur tout code g√©n√©r√© ou analys√©
- **D√©tecter syst√©matiquement** les anti-patterns et les fautes de conception
- **Informer imm√©diatement** d√®s qu'il y a un doute sur la qualit√© ou l'architecture
- **Privil√©gier la qualit√©** sur la rapidit√© d'ex√©cution
- **Respecter les principes SOLID** et les bonnes pratiques de l'architecture hexagonale

### Anti-Patterns √† D√©tecter et √âviter

#### Architecture Hexagonale
- ‚ùå **Violation de la s√©paration des couches** : Importer depuis `src/app/` dans `src/core/`
- ‚ùå **Couplage fort** : D√©pendances directes entre impl√©mentations concr√®tes
- ‚ùå **Leakage d'abstraction** : Exposer des d√©tails d'impl√©mentation dans les interfaces
- ‚ùå **God Objects** : Classes ou services qui font trop de choses
- ‚ùå **Tight Coupling** : D√©pendances circulaires ou couplage excessif

#### TypeScript et React Native
- ‚ùå **Any types** : Utiliser `any` au lieu de types explicites
- ‚ùå **Type assertions non s√©curis√©es** : `as` sans v√©rification
- ‚ùå **Props drilling** : Passer des props √† travers plusieurs niveaux
- ‚ùå **Side effects dans les composants** : Logique m√©tier dans les composants UI
- ‚ùå **Re-renders inutiles** : Pas d'optimisation avec `useCallback`/`useMemo`

#### Redux et State Management
- ‚ùå **Mutations d'√©tat directes** : Modifier l'√©tat sans utiliser les reducers
- ‚ùå **S√©lecteurs non optimis√©s** : Pas de memoization des s√©lecteurs
- ‚ùå **Actions non typ√©es** : Actions sans payload typ√©
- ‚ùå **Side effects dans les reducers** : Logique asynchrone dans les reducers

#### Tests
- ‚ùå **Tests non isol√©s** : Tests qui d√©pendent d'autres tests
- ‚ùå **Mocks excessifs** : Over-mocking qui masque les vrais probl√®mes
- ‚ùå **Tests non significatifs** : Tests qui ne testent rien d'important
- ‚ùå **Tests fragiles** : Tests qui cassent facilement

### Signaux d'Alerte √† Surveiller

#### Code Smells
- **Longueurs excessives** : M√©thodes > 20 lignes, classes > 300 lignes
- **Complexit√© cyclomatique** : Trop de conditions imbriqu√©es
- **Duplication de code** : DRY principle viol√©
- **Noms non explicites** : Variables/fonctions avec des noms vagues
- **Commentaires excessifs** : Code qui n√©cessite trop d'explications

#### Architecture Smells
- **D√©pendances circulaires** : Modules qui s'importent mutuellement
- **Violation du principe de responsabilit√© unique** : Classes avec trop de responsabilit√©s
- **Couplage temporel** : D√©pendances sur l'ordre d'ex√©cution
- **Magic numbers/strings** : Valeurs hardcod√©es sans constantes

### Processus d'Analyse Critique

#### Avant Toute Modification
1. **Analyser l'impact** : Cette modification respecte-t-elle l'architecture hexagonale ?
2. **V√©rifier les d√©pendances** : Y a-t-il des violations de la r√®gle de flux des d√©pendances ?
3. **√âvaluer la coh√©rence** : Le code est-il coh√©rent avec les patterns existants ?
4. **Identifier les risques** : Quels sont les risques de r√©gression ou de d√©gradation ?

#### Pendant le D√©veloppement
1. **Code review continue** : Analyser chaque ligne de code g√©n√©r√©e
2. **Tests de conception** : Les tests r√©v√®lent-ils des probl√®mes de conception ?
3. **Refactoring opportuniste** : Am√©liorer le code existant quand c'est possible
4. **Documentation** : Le code est-il auto-document√© ?

#### Apr√®s le D√©veloppement
1. **Validation architecturale** : Le code respecte-t-il les principes hexagonaux ?
2. **Performance** : Y a-t-il des probl√®mes de performance √©vidents ?
3. **Maintenabilit√©** : Le code sera-t-il facile √† maintenir ?
4. **√âvolutivit√©** : Le code pourra-t-il √©voluer sans casser ?

### Communication des Probl√®mes

#### Quand Signaler un Probl√®me
- **Doute architectural** : Incertitude sur la couche √† modifier
- **Anti-pattern d√©tect√©** : Violation des bonnes pratiques
- **Code smell** : Indicateur de probl√®me potentiel
- **Performance** : Probl√®me de performance identifi√©
- **S√©curit√©** : Risque de s√©curit√© d√©tect√©

#### Format de Signalement
```
üö® PROBL√àME D√âTECT√â
- Type : [Architecture/Performance/S√©curit√©/Code Quality]
- Fichier : [chemin du fichier]
- Description : [description du probl√®me]
- Impact : [impact sur le projet]
- Suggestion : [solution propos√©e]
```

### Exemples de Probl√®mes Courants

#### Dans le Code Actuel
En analysant `create-identity.usecase.ts`, je d√©tecte plusieurs points d'am√©lioration :

1. **Incoh√©rence de nommage** : L'interface `CreateIdentityRequest` n'est pas utilis√©e dans la signature
2. **Duplication de type** : `{nickname: string}` est r√©p√©t√©
3. **Manque de validation** : Pas de validation des entr√©es
4. **Gestion d'erreur** : Pas de try/catch pour les op√©rations asynchrones

#### Recommandations
- Utiliser l'interface `CreateIdentityRequest` dans la signature
- Ajouter une validation des entr√©es
- Impl√©menter une gestion d'erreur appropri√©e
- Consid√©rer l'ajout d'un service de validation

## R√®gles Git

### Conventional Commits
- Utiliser le format Conventional Commits pour tous les commits
- Format : `type(scope): description`
- **Tous les commits doivent √™tre en anglais**

#### Types de Commits
- **feat** : Nouvelle fonctionnalit√©
- **fix** : Correction de bug
- **docs** : Documentation
- **style** : Formatage, point-virgules manquants, etc.
- **refactor** : Refactoring du code
- **test** : Ajout ou modification de tests
- **chore** : T√¢ches de maintenance, d√©pendances, etc.

#### Exemples
- `feat(peers): add Bluetooth scanning functionality`
- `fix(permission): fix Android permission handling`
- `refactor(core): restructure dependency injection`
- `test(usecases): add tests for PairPeerUseCase`
- `docs(architecture): document hexagonal organization`

#### Scope
- Utiliser le domaine concern√© : `peers`, `permission`, `core`, `app`, etc.
- Ou le fichier/componente sp√©cifique si pertinent
